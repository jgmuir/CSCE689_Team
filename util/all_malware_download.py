# Brandon Gathright and Yukon Peng
# Download the list of all malware sample sha256 from malware bazaar and select a random subset to download to a user supplied directory with the naming convention XXXX 4-digit number

import os
import sys
import pandas as pd
import requests
import random
import pyzipper

def main():
    # Set the path to the local CSV file to read
    sample_filename = sys.argv[1]

    # Set the directory to save the downloaded files
    output_dir = sys.argv[2]

    # Set the number of samples to download
    sample_count = 1000
    if len(sys.argv) > 3:
        sample_count = int(sys.argv[3])

    # Create the output directory if it doesn't exist
    if not os.path.exists(output_dir):
        os.mkdir(output_dir)

    # Get the start index for the sample as the maximum sample number in the output directory plus 1
    idx = 0
    if len(os.listdir(output_dir)) != 0:
        idx = max([int(file.split(".")[0]) for file in os.listdir(output_dir)])+1

    # Open the sha256 CSV file and load the exe and dll entries into a list
    sha256_list = []
    try:
        sample_df = pd.read_csv(sample_filename)
        windows_samples = sample_df.loc[sample_df['mime_type'] == " \"application/x-dosexec\""]
        sha256_list = [hash.strip().split("\"")[1] for hash in list(windows_samples['sha256_hash'])]
    except:
        print("Problem reading sample file, exiting")
        return

    # Select random samples from the list
    download_list = random.sample(sha256_list, int(sample_count))
            
    # Define hard-coded constants
    ZIP_PASSWORD = b'infected'
    headers = { 'API-KEY': '' }

    # Download all samples in the downlad list
    for sha256_hash in download_list:
        # Create the paramaters for the current sample
        data = {
            'query': 'get_file',
            'sha256_hash': sha256_hash,
        }

        # Download the file from malware bazaar
        response = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, timeout=15, headers=headers, allow_redirects=True)

        print(response.content)

        # If the download was not successful
        if 'file_not_found' in response.text:
            print("Error: problem downloading sample " + str(sha256_hash) + ", skipping.")
            continue
        else:
            # Set the path to save the downloaded file
            output_path = os.path.join(output_dir, str("{0:0=4d}".format(idx)))

            # Write the response content to file
            open(output_path+".zip", 'wb').write(response.content)

            try:
                with pyzipper.AESZipFile(output_path+".zip") as zf:
                    zf.pwd = ZIP_PASSWORD
                    my_secrets = zf.extractall(output_dir)
                    if os.path.isfile(os.path.join(output_dir, sha256_hash+".exe")):
                        os.rename(os.path.join(output_dir, sha256_hash+".exe"), output_path)
                    elif os.path.isfile(os.path.join(output_dir, sha256_hash+".dll")):
                        os.rename(os.path.join(output_dir, sha256_hash+".dll"), output_path)
                    elif os.path.isfile(os.path.join(output_dir, sha256_hash+".xll")):
                        os.rename(os.path.join(output_dir, sha256_hash+".xll"), output_path)
                os.remove((output_path+".zip"))
                idx += 1
            except:
                os.remove((output_path+".zip"))
    return

if __name__ == "__main__":
    main()